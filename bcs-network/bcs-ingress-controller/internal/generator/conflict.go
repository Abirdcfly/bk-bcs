/*
 * Tencent is pleased to support the open source community by making Blueking Container Service available.,
 * Copyright (C) 2019 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under,
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

package generator

import (
	"context"
	"fmt"

	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/Tencent/bk-bcs/bcs-common/common/blog"
	networkextensionv1 "github.com/Tencent/bk-bcs/bcs-k8s/kubernetes/apis/networkextension/v1"
)

func generateRuleConflictMessage(rule networkextensionv1.IngressRule,
	ingressName, ingressNamespace, lisIngressName, lisIngressNamespace string) string {
	return fmt.Sprintf("[conflict] rule %+v of ingress %s/%s is conflict with ingress %s/%s",
		rule, ingressName, ingressNamespace, lisIngressName, lisIngressNamespace)
}

func generateMappingConflictMessage(mapping networkextensionv1.IngressPortMapping,
	ingressName, ingressNamespace, lisIngressName, lisIngressNamespace string) string {
	return fmt.Sprintf("[conflict] mapping %+v of ingress %s/%s is conflict with ingress %s/%s",
		mapping, ingressName, ingressNamespace, lisIngressName, lisIngressNamespace)
}

func getKeyByValue(m map[string]string, value string) string {
	for k, v := range m {
		if v == value {
			return k
		}
	}
	return ""
}

func isRuleConflict(ingressName, ingressNamespace string,
	rule networkextensionv1.IngressRule,
	existedListenerMap map[int]networkextensionv1.Listener) (bool, string) {

	existedListener, ok := existedListenerMap[rule.Port]
	if !ok {
		return false, ""
	}

	// when existed listener with same port was generated by this ingress, we think it is not conflict
	// otherwise, return true and return conflict message
	ingressNameValue, okLisIngressName := existedListener.Labels[ingressName]
	ingressNamespaceValue, okLisIngressNamespace := existedListener.Labels[ingressNamespace]
	if !okLisIngressName || !okLisIngressNamespace ||
		ingressNameValue != networkextensionv1.LabelValueForIngressName ||
		ingressNamespaceValue != networkextensionv1.LabelValueForIngressNamespace {
		conflictName := getKeyByValue(existedListener.Labels, networkextensionv1.LabelValueForIngressName)
		conflictNs := getKeyByValue(existedListener.Labels, networkextensionv1.LabelValueForIngressNamespace)
		conflictMsg := generateRuleConflictMessage(rule, ingressName, ingressNamespace,
			conflictName, conflictNs)
		blog.Warnf(conflictMsg)
		return true, conflictMsg
	}
	return false, ""
}

func isMappingConflict(ingressName, ingressNamespace string,
	mapping networkextensionv1.IngressPortMapping,
	existedListenerMap map[int]networkextensionv1.Listener) (bool, string) {

	for i := mapping.StartIndex; i < mapping.EndIndex; i++ {
		existedListener, ok := existedListenerMap[mapping.StartPort+i]
		if !ok {
			continue
		}
		ingressNameValue, okLisIngressName := existedListener.Labels[ingressName]
		ingressNamespaceValue, okLisIngressNamespace := existedListener.Labels[ingressNamespace]
		if !okLisIngressName || !okLisIngressNamespace ||
			ingressNameValue != networkextensionv1.LabelValueForIngressName ||
			ingressNamespaceValue != networkextensionv1.LabelValueForIngressNamespace {
			conflictName := getKeyByValue(existedListener.Labels, networkextensionv1.LabelValueForIngressName)
			conflictNs := getKeyByValue(existedListener.Labels, networkextensionv1.LabelValueForIngressNamespace)
			conflictMsg := generateMappingConflictMessage(mapping, ingressName, ingressNamespace,
				conflictName, conflictNs)
			blog.Warnf(conflictMsg)
			return false, conflictMsg
		}
	}
	return false, ""
}

func (g *IngressConverter) checkConflicts(ingress *networkextensionv1.Ingress) (bool, error) {
	existedListeners := &networkextensionv1.ListenerList{}
	err := g.cli.List(context.TODO(), existedListeners, &client.ListOptions{})
	if err != nil {
		blog.Errorf("failed list existed Listeners err %s", err.Error())
		return false, fmt.Errorf("failed list existed Listeners err %s", err.Error())
	}

	// use map
	existedListenerMap := make(map[int]networkextensionv1.Listener)
	for index, listener := range existedListeners.Items {
		// listener for port segment
		if listener.Spec.EndPort > 0 {
			for i := listener.Spec.Port; i <= listener.Spec.EndPort; i++ {
				existedListenerMap[i] = existedListeners.Items[index]
			}
			continue
		}
		existedListenerMap[listener.Spec.Port] = existedListeners.Items[index]
	}

	for _, rule := range ingress.Spec.Rules {
		isConflict, _ := isRuleConflict(ingress.GetName(), ingress.GetNamespace(), rule, existedListenerMap)
		if isConflict {
			return true, nil
		}
	}
	for _, mapping := range ingress.Spec.PortMappings {
		isConflict, _ := isMappingConflict(ingress.GetName(), ingress.GetNamespace(), mapping, existedListenerMap)
		if isConflict {
			return true, nil
		}
	}
	return false, nil
}


func checkConflictsInIngress(ingress *networkextensionv1.Ingress) (bool, string) {
	ruleMap := make(map[int]networkextensionv1.IngressRule)
	for index, rule := range ingress.Spec.Rules {
		existedRule, ok := ruleMap[rule.Port]
		if !ok {
			ruleMap[rule.Port] = ingress.Spec.Rules[index]
			continue
		}
		return false, fmt.Sprintf("%+v conflicts with %+v", rule, existedRule)
	}

	for i := 0; i < len(ingress.Spec.PortMappings)-1; i++ {
		mapping := ingress.Spec.PortMappings[i]
		for port, rule := range ruleMap {
			if port >= mapping.StartPort+mapping.StartIndex && port < mapping.StartPort+mapping.EndIndex {
				return false, fmt.Sprintf("%+v port conflicts with %+v", mapping, rule)
			}
		}
		for j := i + 1; j < len(ingress.Spec.PortMappings); j++ {
			tmpMapping := ingress.Spec.PortMappings[j]
			if mapping.StartPort+mapping.StartIndex > tmpMapping.StartPort+tmpMapping.EndIndex ||
				mapping.StartPort+mapping.EndIndex < tmpMapping.StartPort+tmpMapping.StartIndex {
				continue
			}
			return false, fmt.Sprintf("%+v ports conflicts with %+v", mapping, tmpMapping)
		}
	}
	return true, ""
}
